<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Flow</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Flow.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">flow-1.0.12: Write more understandable Haskell.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Flow</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Function application</a></li><li><a href="#g:2">Function composition</a></li><li><a href="#g:3">Strict function application</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Flow provides operators for writing more understandable Haskell. It is an
 alternative to some common idioms like (<code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:-36-">$</a></code>) for function
 application and (<code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:.">.</a></code>) for function composition.</p><p>Flow is designed to be imported unqualified. It does not export anything
 that conflicts with the base package.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Flow
</code></strong></pre><h2>Rationale</h2><p>I think that Haskell can be hard to read. It has two operators for applying
 functions. Both are not really necessary and only serve to reduce
 parentheses. But they make code hard to read. People who do not already
 know Haskell have no chance of guessing what <code>foo $ bar</code> or <code>baz &amp; qux</code>
 mean.</p><p>Those that do know Haskell are forced to read lines forwards and backwards
 at the same time, thanks to function composition. Even something simple,
 like finding the minimum element, bounces around: <code>f = head . sort</code>.</p><p>I think we can do better. By using directional operators, we can allow
 readers to move their eye in only one direction, be that left-to-right or
 right-to-left. And by using idioms common in other programming languages,
 we can allow people who aren't familiar with Haskell to guess at the
 meaning.</p><p>So instead of (<code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:-36-">$</a></code>), I propose (<code><a href="Flow.html#v:-60--124-">&lt;|</a></code>). It is a pipe, which anyone
 who has touched a Unix system should be familiar with. And it points in the
 direction it sends arguments along. Similarly, replace (<code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:-38-">&amp;</a></code>) with
 (<code><a href="Flow.html#v:-124--62-">|&gt;</a></code>). And for composition, (<code><a href="Flow.html#v:-60-.">&lt;.</a></code>) replaces (<code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:.">.</a></code>). I would have
 preferred <code>&lt;&lt;</code>, but its counterpart <code>&gt;&gt;</code> is taken by Haskell's syntax.
 So-called &quot;backwards&quot; composition is normally expressed with
 (<code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Control-Category.html#v:-62--62--62-">&gt;&gt;&gt;</a></code>), which Flow provides as (<code><a href="Flow.html#v:.-62-">.&gt;</a></code>).</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:-124--62-">(|&gt;)</a> :: a -&gt; (a -&gt; b) -&gt; b</li><li class="src short"><a href="#v:-60--124-">(&lt;|)</a> :: (a -&gt; b) -&gt; a -&gt; b</li><li class="src short"><a href="#v:apply">apply</a> :: a -&gt; (a -&gt; b) -&gt; b</li><li class="src short"><a href="#v:.-62-">(.&gt;)</a> :: (a -&gt; b) -&gt; (b -&gt; c) -&gt; a -&gt; c</li><li class="src short"><a href="#v:-60-.">(&lt;.)</a> :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</li><li class="src short"><a href="#v:compose">compose</a> :: (a -&gt; b) -&gt; (b -&gt; c) -&gt; a -&gt; c</li><li class="src short"><a href="#v:-33--62-">(!&gt;)</a> :: a -&gt; (a -&gt; b) -&gt; b</li><li class="src short"><a href="#v:-60--33-">(&lt;!)</a> :: (a -&gt; b) -&gt; a -&gt; b</li><li class="src short"><a href="#v:apply-39-">apply'</a> :: a -&gt; (a -&gt; b) -&gt; b</li></ul></div><div id="interface"><h1 id="g:1">Function application</h1><div class="top"><p class="src"><a id="v:-124--62-" class="def">(|&gt;)</a> :: a -&gt; (a -&gt; b) -&gt; b <span class="fixity">infixl 0</span><span class="rightedge"></span> <a href="#v:-124--62-" class="selflink">#</a></p><div class="doc"><p>Left-associative <code><a href="Flow.html#v:apply">apply</a></code> operator. Read as &quot;apply forward&quot; or &quot;pipe into&quot;.
 Use this to create long chains of computation that suggest which direction
 things move in.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>3 |&gt; succ |&gt; recip |&gt; negate
</code></strong>-0.25
</pre><p>Or use it anywhere you would use (<code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:-38-">&amp;</a></code>).</p><pre>\ x -&gt; (x |&gt; f) == f x</pre><pre>\ x -&gt; (x |&gt; f |&gt; g) == g (f x)</pre></div></div><div class="top"><p class="src"><a id="v:-60--124-" class="def">(&lt;|)</a> :: (a -&gt; b) -&gt; a -&gt; b <span class="fixity">infixr 0</span><span class="rightedge"></span> <a href="#v:-60--124-" class="selflink">#</a></p><div class="doc"><p>Right-associative <code><a href="Flow.html#v:apply">apply</a></code> operator. Read as &quot;apply backward&quot; or &quot;pipe
 from&quot;. Use this to create long chains of computation that suggest which
 direction things move in. You may prefer this operator over (<code><a href="Flow.html#v:-124--62-">|&gt;</a></code>) for
 <code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:IO">IO</a></code> actions since it puts the last function first.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>print &lt;| negate &lt;| recip &lt;| succ &lt;| 3
</code></strong>-0.25
</pre><p>Or use it anywhere you would use (<code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:-36-">$</a></code>).</p><p>Note that (<code><a href="Flow.html#v:-60--124-">&lt;|</a></code>) and (<code><a href="Flow.html#v:-124--62-">|&gt;</a></code>) have the same precedence, so they cannot be used
 together.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>-- This doesn't work!
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>-- print &lt;| 3 |&gt; succ |&gt; recip |&gt; negate
</code></strong></pre><pre>\ x -&gt; (f &lt;| x) == f x</pre><pre>\ x -&gt; (g &lt;| f &lt;| x) == g (f x)</pre></div></div><div class="top"><p class="src"><a id="v:apply" class="def">apply</a> :: a -&gt; (a -&gt; b) -&gt; b <a href="#v:apply" class="selflink">#</a></p><div class="doc"><p>Function application. This function usually isn't necessary, but it can be
 more readable than some alternatives when used with higher-order functions
 like <code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:map">map</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (apply 2) [succ, recip, negate]
</code></strong>[3.0,0.5,-2.0]
</pre><p>In general you should prefer using an explicit lambda or operator section.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (\ f -&gt; 2 |&gt; f) [succ, recip, negate]
</code></strong>[3.0,0.5,-2.0]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (2 |&gt;) [succ, recip, negate]
</code></strong>[3.0,0.5,-2.0]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (&lt;| 2) [succ, recip, negate]
</code></strong>[3.0,0.5,-2.0]
</pre><pre>\ x -&gt; apply x f == f x</pre></div></div><h1 id="g:2">Function composition</h1><div class="top"><p class="src"><a id="v:.-62-" class="def">(.&gt;)</a> :: (a -&gt; b) -&gt; (b -&gt; c) -&gt; a -&gt; c <span class="fixity">infixl 9</span><span class="rightedge"></span> <a href="#v:.-62-" class="selflink">#</a></p><div class="doc"><p>Left-associative <code><a href="Flow.html#v:compose">compose</a></code> operator. Read as &quot;compose forward&quot; or &quot;and
 then&quot;. Use this to create long chains of computation that suggest which
 direction things move in.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let f = succ .&gt; recip .&gt; negate
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>f 3
</code></strong>-0.25
</pre><p>Or use it anywhere you would use (<code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Control-Category.html#v:-62--62--62-">&gt;&gt;&gt;</a></code>).</p><pre>\ x -&gt; (f .&gt; g) x == g (f x)</pre><pre>\ x -&gt; (f .&gt; g .&gt; h) x == h (g (f x))</pre></div></div><div class="top"><p class="src"><a id="v:-60-." class="def">(&lt;.)</a> :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c <span class="fixity">infixr 9</span><span class="rightedge"></span> <a href="#v:-60-." class="selflink">#</a></p><div class="doc"><p>Right-associative <code><a href="Flow.html#v:compose">compose</a></code> operator. Read as &quot;compose backward&quot; or &quot;but
 first&quot;. Use this to create long chains of computation that suggest which
 direction things move in. You may prefer this operator over (<code><a href="Flow.html#v:.-62-">.&gt;</a></code>) for
 <code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:IO">IO</a></code> actions since it puts the last function first.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let f = print &lt;. negate &lt;. recip &lt;. succ
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>f 3
</code></strong>-0.25
</pre><p>Or use it anywhere you would use (<code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:.">.</a></code>).</p><p>Note that (<code><a href="Flow.html#v:-60-.">&lt;.</a></code>) and (<code><a href="Flow.html#v:.-62-">.&gt;</a></code>) have the same precedence, so they cannot be used
 together.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>-- This doesn't work!
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>-- print &lt;. succ .&gt; recip .&gt; negate
</code></strong></pre><pre>\ x -&gt; (g &lt;. f) x == g (f x)</pre><pre>\ x -&gt; (h &lt;. g &lt;. f) x == h (g (f x))</pre></div></div><div class="top"><p class="src"><a id="v:compose" class="def">compose</a> :: (a -&gt; b) -&gt; (b -&gt; c) -&gt; a -&gt; c <a href="#v:compose" class="selflink">#</a></p><div class="doc"><p>Function composition. This function usually isn't necessary, but it can be
 more readable than some alternatives when used with higher-order functions
 like <code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:map">map</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let fs = map (compose succ) [recip, negate]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (apply 3) fs
</code></strong>[0.25,-4.0]
</pre><p>In general you should prefer using an explicit lambda or operator section.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (\ f -&gt; f 3) (map (\ f -&gt; succ .&gt; f) [recip, negate])
</code></strong>[0.25,-4.0]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (\ f -&gt; f 3) (map (succ .&gt;) [recip, negate])
</code></strong>[0.25,-4.0]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (\ f -&gt; f 3) (map (&lt;. succ) [recip, negate])
</code></strong>[0.25,-4.0]
</pre><pre>\ x -&gt; compose f g x == g (f x)</pre></div></div><h1 id="g:3">Strict function application</h1><div class="top"><p class="src"><a id="v:-33--62-" class="def">(!&gt;)</a> :: a -&gt; (a -&gt; b) -&gt; b <span class="fixity">infixl 0</span><span class="rightedge"></span> <a href="#v:-33--62-" class="selflink">#</a></p><div class="doc"><p>Left-associative <code><a href="Flow.html#v:apply-39-">apply'</a></code> operator. Read as &quot;strict apply forward&quot; or
 &quot;strict pipe info&quot;. Use this to create long chains of computation that
 suggest which direction things move in.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>3 !&gt; succ !&gt; recip !&gt; negate
</code></strong>-0.25
</pre><p>The difference between this and (<code><a href="Flow.html#v:-124--62-">|&gt;</a></code>) is that this evaluates its argument
 before passing it to the function.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>undefined |&gt; const True
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>undefined !&gt; const True
</code></strong>*** Exception: Prelude.undefined
...
</pre><pre>\ x -&gt; (x !&gt; f) == seq x (f x)</pre><pre>\ x -&gt; (x !&gt; f !&gt; g) == let y = seq x (f x) in seq y (g y)</pre></div></div><div class="top"><p class="src"><a id="v:-60--33-" class="def">(&lt;!)</a> :: (a -&gt; b) -&gt; a -&gt; b <span class="fixity">infixr 0</span><span class="rightedge"></span> <a href="#v:-60--33-" class="selflink">#</a></p><div class="doc"><p>Right-associative <code><a href="Flow.html#v:apply-39-">apply'</a></code> operator. Read as &quot;strict apply backward&quot; or
 &quot;strict pipe from&quot;. Use this to create long chains of computation that
 suggest which direction things move in. You may prefer this operator over
 (<code><a href="Flow.html#v:-33--62-">!&gt;</a></code>) for <code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:IO">IO</a></code> actions since it puts the last function first.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>print &lt;! negate &lt;! recip &lt;! succ &lt;! 3
</code></strong>-0.25
</pre><p>The difference between this and (<code><a href="Flow.html#v:-60--124-">&lt;|</a></code>) is that this evaluates its argument
 before passing it to the function.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>const True &lt;| undefined
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>const True &lt;! undefined
</code></strong>*** Exception: Prelude.undefined
...
</pre><p>Note that (<code><a href="Flow.html#v:-60--33-">&lt;!</a></code>) and (<code><a href="Flow.html#v:-33--62-">!&gt;</a></code>) have the same precedence, so they cannot be used
 together.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>-- This doesn't work!
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>-- print &lt;! 3 !&gt; succ !&gt; recip !&gt; negate
</code></strong></pre><pre>\ x -&gt; (f &lt;! x) == seq x (f x)</pre><pre>\ x -&gt; (g &lt;! f &lt;! x) == let y = seq x (f x) in seq y (g y)</pre></div></div><div class="top"><p class="src"><a id="v:apply-39-" class="def">apply'</a> :: a -&gt; (a -&gt; b) -&gt; b <a href="#v:apply-39-" class="selflink">#</a></p><div class="doc"><p>Strict function application. This function usually isn't necessary, but it
 can be more readable than some alternatives when used with higher-order
 functions like <code><a href="file:///Library/Frameworks/GHC.framework/Versions/8.0.1-x86_64/usr/share/doc/ghc-8.0.1/html/libraries/base-4.9.0.0/Prelude.html#v:map">map</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (apply' 2) [succ, recip, negate]
</code></strong>[3.0,0.5,-2.0]
</pre><p>The different between this and <code><a href="Flow.html#v:apply">apply</a></code> is that this evaluates its argument
 before passing it to the function.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>apply undefined (const True)
</code></strong>True
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>apply' undefined (const True)
</code></strong>*** Exception: Prelude.undefined
...
</pre><p>In general you should prefer using an explicit lambda or operator section.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (\ f -&gt; 2 !&gt; f) [succ, recip, negate]
</code></strong>[3.0,0.5,-2.0]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (2 !&gt;) [succ, recip, negate]
</code></strong>[3.0,0.5,-2.0]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>map (&lt;! 2) [succ, recip, negate]
</code></strong>[3.0,0.5,-2.0]
</pre><pre>\ x -&gt; apply' x f == seq x (f x)</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.17.2</p></div></body></html>